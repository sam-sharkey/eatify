from openai import OpenAI
import requests
from django.core.management.base import BaseCommand
from django.db import IntegrityError
from api.models import MenuItem, Restaurant, Highlight
from dotenv import load_dotenv
import os
import re

load_dotenv()  # Load environment variables from .env file

# example to generate app python manage.py generate_items "A cozy bakery that specializes in artisan bread and pastries." --categories 4 --items-per-category 5

client = OpenAI(api_key=os.getenv("OPENAI_KEY"))

class Command(BaseCommand):
    help = 'Populate MenuItems and Highlights with data generated by OpenAI'

    def add_arguments(self, parser):
        parser.add_argument('description', type=str, help='Description of the restaurant')
        parser.add_argument('--restaurant-id', type=int, default=None, help='The ID of the restaurant to generate items for')
        parser.add_argument('--categories', type=int, default=3, help='Number of unique categories')
        parser.add_argument('--items-per-category', type=int, default=3, help='Number of items per category')

    def handle(self, *args, **options):
        description = options['description']
        num_categories = options['categories']
        items_per_category = options['items_per_category']
        restaurant_id = options['restaurant_id']

        restaurant = Restaurant.objects.get(pk=restaurant_id) if restaurant_id else Restaurant.objects.last()
        if not restaurant:
            self.stdout.write(self.style.ERROR("No restaurant found. Please add a restaurant first."))
            return

        # Generate MenuItems using OpenAI
        #menu_items = self.generate_menu_items(description, num_categories, items_per_category)

        # Process and create MenuItems
        #self.create_menu_items(restaurant, menu_items)

        # Generate highlight data using OpenAI
        highlight_data = self.generate_highlights(description)

        # Process and create Highlight objects
        self.create_highlights(restaurant, highlight_data)

    def generate_menu_items(self, description, num_categories, items_per_category):
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": (
                f"Generate {num_categories*items_per_category} menu items. Among them there should be {num_categories} unique menu categories, each with {items_per_category} menu items per category, "
                f"for a restaurant that {description}. "
                f"For each menu item, follow this exact format:\n"
                f"Category: [Category Name]\n"
                f"Name: [Item Name]\n"
                f"Description: [Item Description]\n"
                f"Image Description: [Image Description]\n"
                f"Use '---' to separate each menu item clearly. Always include the Category name before each item, even if itâ€™s the same as the previous one."
            )},
        ]
        response = client.chat.completions.create(model="gpt-4o-mini",  messages=messages, stop=None, temperature=0.7)

        response_text = response.choices[0].message.content
        result = self.extract_menu_items(response_text)
        return result

    def extract_menu_items(self, response_text):
        menu_items = []
        current_category = None
        
        # Split by '---' which separates each item or category section
        sections = response_text.split('---')
        
        for section in sections:
            section = section.strip()
            if not section:
                continue
            
            # Look for a category within the section
            category_match = re.search(r"Category:\s*(.+)", section)
            if category_match:
                current_category = category_match.group(1).strip()
            
            # Parse the individual menu item
            name_match = re.search(r"Name:\s*(.+)", section)
            description_match = re.search(r"Description:\s*(.+)", section)
            image_description_match = re.search(r"Image Description:\s*(.+)", section)
            
            if current_category and name_match and description_match and image_description_match:
                menu_items.append({
                    'name': name_match.group(1).strip(),
                    'description': description_match.group(1).strip(),
                    'classification': current_category,
                    'image_description': image_description_match.group(1).strip()
                })
        
        return menu_items


    def create_menu_items(self, restaurant, menu_items):
        for item in menu_items:
            try:
                # Generate an image using DALL-E or a similar model
                image_url = self.generate_image(item['image_description'])

                # Download the image
                image_response = requests.get(image_url)
                if image_response.status_code == 200:
                    image_filename = f"{item['name'].replace(' ', '_')}.png"
                    image_path = f"menu_items/{image_filename}"

                    with open(f"media/{image_path}", 'wb') as img_file:
                        img_file.write(image_response.content)

                    # Create the MenuItem with the image
                    MenuItem.objects.create(
                        restaurant=restaurant,
                        name=item['name'],
                        description=item['description'],
                        classification=item['classification'],
                        image_src=image_path,
                    )
                    self.stdout.write(self.style.SUCCESS(f"MenuItem '{item['name']}' created successfully."))
                else:
                    self.stdout.write(self.style.ERROR(f"Failed to download image for '{item['name']}'"))

            except IntegrityError:
                self.stdout.write(self.style.WARNING(f"MenuItem '{item['name']}' already exists."))

    def generate_image(self, description):
        response = client.images.generate(
            model="dall-e-2",
            prompt=description,
            n=1,
            size="1024x1024",
            quality="standard",
        )

        return response.data[0].url  # This returns the URL of the generated image

    def populate_highlights(self):
        restaurant = Restaurant.objects.first()
        if not restaurant:
            self.stdout.write(self.style.ERROR("No restaurant found. Please add a restaurant first."))
            return

        # Generate highlight data using OpenAI
        highlight_data = self.generate_highlights()

        # Process and create Highlight objects
        self.create_highlights(restaurant, highlight_data)

    def generate_highlights(self, description):
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": (
                f"Generate Highlight entries for a restaurant's website that does {description}."
                f"There should be three categories (further defined as Tag): 'FeaturedMenu', 'Highlight', and 'News' , each with 2-3 entries."
                f"For each highlight, follow this exact format:\n"
                f"Title: [Title]\n"
                f"Header: [Header]\n"
                f"Description1: [Description1]\n"
                f"Description2: [Description2]\n"
                f"Image Description: [Image Description]\n"
                f"Tag: [Tag]\n"
                f"Use '---' to separate each menu item clearly."
            )},
        ]
        response = client.chat.completions.create(model="gpt-4o-mini",  messages=messages, stop=None, temperature=0.7)

        response_text = response.choices[0].message.content 

        return self.extract_highlights(response_text)

    def extract_highlights(self, response_text):
        highlights = []
        current_tag = None

        # Split by '---' which separates each entry
        sections = response_text.split('---')
        
        for section in sections:
            section = section.strip()
            if not section:
                continue
            
            # Look for the tag within the section
            if "FeaturedMenu" in section:
                current_tag = "FeaturedMenu"
            elif "Highlight" in section:
                current_tag = "Highlight"
            elif "News" in section:
                current_tag = "News"
            
            # Parse the individual highlight entry
            title_match = re.search(r"Title:\s*(.+)", section)
            header_match = re.search(r"Header:\s*(.+)", section)
            description1_match = re.search(r"Description1:\s*(.+)", section)
            description2_match = re.search(r"Description2:\s*(.+)", section)
            image_description_match = re.search(r"Image Description:\s*(.+)", section)

            highlight = {
                'title': title_match.group(1).strip() if title_match else None,
                'header': header_match.group(1).strip() if header_match else None,
                'description1': description1_match.group(1).strip() if description1_match else None,
                'description2': description2_match.group(1).strip() if description2_match else None,
                'image_description': image_description_match.group(1).strip() if image_description_match else None,
                'tag': current_tag
            }

            if highlight['title'] and highlight['header'] and highlight['image_description'] and current_tag:
                highlights.append(highlight)
        
        return highlights

    def create_highlights(self, restaurant, highlight_data):
        for highlight in highlight_data:
            try:
                # Generate an image using DALL-E or a similar model
                image_url = self.generate_image(highlight['image_description'])

                # Download the image
                image_response = requests.get(image_url)
                if image_response.status_code == 200:
                    image_filename = f"{highlight['title'].replace(' ', '_')}.png"
                    image_path = f"highlights/{image_filename}"

                    with open(f"media/{image_path}", 'wb') as img_file:
                        img_file.write(image_response.content)
                Highlight.objects.create(restaurant=restaurant, image_src=image_path, title=highlight['title'],
                                          header=highlight['header'],  description1=highlight['description1'],  
                                          description2=highlight['description2'],
                                          tag=highlight['tag'])
                self.stdout.write(self.style.SUCCESS(f"Highlight '{highlight['title']}' created successfully."))
            except IntegrityError:
                self.stdout.write(self.style.WARNING(f"Highlight '{highlight['title']}' already exists."))

        self.stdout.write(self.style.SUCCESS("Highlights populated successfully!"))
